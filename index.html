<script type="text/javascript">
//<![CDATA[
(function() {
	const canvas = document.getElementById('canvas');
	const overlay = document.getElementById('start-overlay');
	const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
	const isMobile = /Android|iPhone|iPad|iPod|Opera Mini|IEMobile|Mobile/i.test(navigator.userAgent);

	// Adjust overlay message for iOS
	if (isIOS) {
		overlay.textContent = "ROTATE YOUR PHONE";
	}

	async function enterFullscreenAndLandscape() {
		try {
			if (!isIOS) {
				if (canvas.requestFullscreen) await canvas.requestFullscreen();
				else if (canvas.webkitRequestFullscreen) await canvas.webkitRequestFullscreen();

				if (screen.orientation && screen.orientation.lock) {
					await screen.orientation.lock('landscape');
				}
			}
		} catch (err) {
			console.warn('Fullscreen or orientation lock failed:', err);
		}
	}

	async function startGameWhenReady() {
		if (isMobile) overlay.style.display = 'flex';

		if (isIOS) {
			// On iOS, wait for rotation to landscape
			const rotationPromise = new Promise(resolve => {
				function checkOrientation() {
					if (window.matchMedia("(orientation: landscape)").matches) {
						window.removeEventListener('orientationchange', checkOrientation);
						overlay.style.display = 'none';
						resolve();
					}
				}
				window.addEventListener('orientationchange', checkOrientation);
				checkOrientation();
			});
			await rotationPromise;
		} else if (isMobile) {
			// Non-iOS mobile: double tap to start
			const startPromise = new Promise(resolve => {
				let tapCount = 0;
				async function clickHandler() {
					tapCount++;
					if (tapCount >= 2) {
						await enterFullscreenAndLandscape();
						if (window.matchMedia("(orientation: landscape)").matches &&
							(document.fullscreenElement || document.webkitFullscreenElement)) {
							document.removeEventListener('click', clickHandler);
							document.removeEventListener('touchstart', clickHandler);
							overlay.style.display = 'none';
							resolve();
						}
					}
				}
				document.addEventListener('click', clickHandler);
				document.addEventListener('touchstart', clickHandler);
			});
			await startPromise;
		} else {
			// Desktop
			overlay.style.display = 'none';
		}

		// âœ… Safe to start Godot engine
		const GODOT_CONFIG = {"args":[],"canvasResizePolicy":2,"executable":"index","experimentalVK":false,"fileSizes":{"index.pck":8931136,"index.wasm":13788612},"focusCanvas":true,"gdnativeLibs":[]};
		var engine = new Engine(GODOT_CONFIG);

		// Progress/status handling
		(function() {
			const INDETERMINATE_STATUS_STEP_MS = 100;
			var statusProgress = document.getElementById('status-progress');
			var statusProgressInner = document.getElementById('status-progress-inner');
			var statusIndeterminate = document.getElementById('status-indeterminate');
			var statusNotice = document.getElementById('status-notice');

			var initializing = true;
			var statusMode = 'hidden';
			var animationCallbacks = [];
			function animate(time) {
				animationCallbacks.forEach(cb => cb(time));
				requestAnimationFrame(animate);
			}
			requestAnimationFrame(animate);

			function setStatusMode(mode) {
				if (statusMode === mode || !initializing) return;
				[statusProgress, statusIndeterminate, statusNotice].forEach(e => e.style.display = 'none');
				animationCallbacks = animationCallbacks.filter(f => f != animateStatusIndeterminate);
				switch(mode){
					case 'progress': statusProgress.style.display='block'; break;
					case 'indeterminate': statusIndeterminate.style.display='block'; animationCallbacks.push(animateStatusIndeterminate); break;
					case 'notice': statusNotice.style.display='block'; break;
					case 'hidden': break;
				}
				statusMode = mode;
			}

			function animateStatusIndeterminate(ms){
				var i=Math.floor(ms/INDETERMINATE_STATUS_STEP_MS%8);
				if(statusIndeterminate.children[i].style.borderTopColor==''){
					Array.prototype.slice.call(statusIndeterminate.children).forEach(child=>child.style.borderTopColor='');
					statusIndeterminate.children[i].style.borderTopColor='#dfdfdf';
				}
			}

			function displayFailureNotice(err){
				console.error(err);
				statusNotice.textContent = err.message || err;
				setStatusMode('notice');
				initializing=false;
			}

			if(!Engine.isWebGLAvailable()) displayFailureNotice('WebGL not available');
			else {
				setStatusMode('indeterminate');
				engine.startGame({
					'onProgress': function(current,total){
						if(total>0){
							statusProgressInner.style.width = current/total*100 + '%';
							setStatusMode('progress');
							if(current===total){ setTimeout(()=>setStatusMode('indeterminate'),500); }
						} else setStatusMode('indeterminate');
					}
				}).then(()=>{ setStatusMode('hidden'); initializing=false; }, displayFailureNotice);
			}
		})();
	}

	startGameWhenReady();
})();
//]]>
</script>
